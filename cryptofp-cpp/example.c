#include <stdio.h>
#include <gmp.h>
#include <cifer/sample/uniform.h>
#include <cifer/innerprod/simple/ddh.h>

int main() {
	size_t l = 500000; // length of input vectors
	mpz_t bound, fe_key, xy, el;
	mpz_inits(bound, fe_key, xy, el, NULL);

	mpz_set_ui(bound, 2); // upper bound for input vector coordinates
	mpz_pow_ui(bound, bound, 10);
	int modulus_len = 1024; // bit length of prime modulus p

	cfe_ddh s, encryptor, decryptor;
	cfe_ddh_init(&s, l, modulus_len, bound);
	cfe_vec msk, mpk, ciphertext, x, y;
	cfe_ddh_master_keys_init(&msk, &mpk, &s);
	cfe_ddh_generate_master_keys(&msk, &mpk, &s);

	// cfe_vec_init(&y, 2);
	// mpz_set_ui(el, 1);
	// cfe_vec_set(&y, el, 0);
	// mpz_set_ui(el, 2);
	// cfe_vec_set(&y, el, 1); // y is [1, 2]

    cfe_vec_init(&y, l);
    cfe_uniform_sample_vec(&y, bound);

	cfe_ddh_derive_fe_key(fe_key, &s, &msk, &y);

	// Simulate instantiation of encryptor 
	// Encryptor wants to hide x and should be given
	// master public key by the trusted entity
	// cfe_vec_init(&x, 2);
	// mpz_set_ui(el, 3);
	// cfe_vec_set(&x, el, 0);
	// mpz_set_ui(el, 4);
	// cfe_vec_set(&x, el, 1); // x is [3, 4]

    cfe_vec_init(&x, l);
    cfe_uniform_sample_vec(&x, bound);

	cfe_ddh_copy(&encryptor, &s);
	cfe_ddh_ciphertext_init(&ciphertext, &encryptor);
	cfe_ddh_encrypt(&ciphertext, &encryptor, &x, &mpk);

	// Simulate instantiation of decryptor that decrypts the cipher 
	// generated by encryptor.
	cfe_ddh_copy(&decryptor, &s);
	// decrypt to obtain the result: inner prod of x and y
	cfe_ddh_decrypt(xy, &decryptor, &ciphertext, fe_key, &y);
	gmp_printf("%Zd\n", xy);

    return 0;
}

